这个东西并不是为Tile-base游戏设计的，其实最初就是想做诸如循环显示的街道背景，山峰，云彩一类，或者是那种循环平铺然后滚动的卡通式背景。也就是无限循环背景。这种东西一向就是复制几个实例然后搬来搬去，几句就能完事。
但要做就得做好点。Tile.as的使用方法很简单：
var t:Tile = new Tile(SkinClass);
t.width = 1000;
t.height = 1000;
addChild(t);

只需要将需要重复显示的类放在构造函数里初始化，然后设置宽高就可以了。显示上和一般的显示对象没什么区别，坐标系与往常相同，也可以正常addChild，看起来就是根据宽高复制了N份皮肤实例的普通Sprite。
但实际上并不是这样。它会根据自己的可显示范围（屏幕和scrollRect）来动态增删内容，只保持会被显示的对象实例。但你不需要关心这点，当成是全部存在的就好。
但要注意的是，它和其他的List一样，会重复使用创建的实例，所以其内部实例是不可靠的。

Tile在增删元素的时候会发布事件，通过监听这两个事件，就可以实现Tile-base的功能，如果元素是MovieClip，可以切换它的帧，或者重新addChild新的内容（这并不会影响原来的元素大小），如果是Bitmap直接设置BitmapData即可，复杂对象也可以在事件中按情况进行处理。Tile在元素增删的时候是有顺序的，生成元素的同时就已经完成了排序，并不需要关心这点。
具体到游戏地图的话，由于地面必须是处于单独的层内（一定在下面），而地面上的物品等等需要和人物一起进行排序，因此没法用原来的排序方法（只排了地面）。只能将Tile作为地面，然后在上面建立一个新层并手动addChild物品，这时候需要知道到底是加到哪一层，RepeatEvent专门提供了一个属性addToLow来表示应当使用addChild()添加还是addChildAt(0)添加，只要这样做了，即使在其他层上添加物品依然是已经排序了的。然后就只需要排序人物就可以了。

Tile45通过重写了Tile的坐标系转换方法，使得显示时被表示成了45度角地图。和Tile一样，仍然可以通过displayToItem,itemToDisplay,getItemPointAtPoint来转换屏幕坐标，内部坐标和元素序号坐标。这两个类基本没有差异，仅仅是显示上做了转换，但getRect方法等等还是返回的原来的值（Rectange也不可能表达菱形）

Example目录有两个文件来演示，其中一个直接设置了viewRect将元素的增删表示了出来。这种做法性能上的消耗依然远小于显示内容的消耗，虽然肯定比写死的要慢，但应该也无所谓。组件中所有基于List的部分都是直接继承于Tile的，仅仅是增加了数据显示和选择，它们即使是做快速缓动滚动也都没有问题，简单的Tile就更不用说了。

元素的体积实际上也可以直接设置。整个Tile完全可以当作一个逻辑对象，监听事件获取坐标，即使引入3D和物理也都可以适应。